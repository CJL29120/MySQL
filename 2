事务隔离：
  在MySQL中，事务支持是在引擎层实现的。
  MySQL原生的MyISAM引擎不支持事务。
  
  ACID（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）;
  当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、
  幻读（phantom read）的问题，为了解决这些问题，就有了“隔离级别”的概念。
  
  事务隔离得越严实，效率就会越低。因此很多时候，要在二者之间寻找一个平衡点。
  SQL标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和
  串行化（serializable ）。
  解释：
  *读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
  *读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
  *可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。
    当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
  *串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，
    后访问的事务必须等前一个事务执行完成，才能继续执行。
    
   *读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。
   *读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。
   *可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。
   *串行：我的事务尚未提交，别人就别想改数据。
   这4种隔离级别，并行性能依次降低，安全性依次提高。
   
  在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
    *在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
    *在“读提交”隔离级别下，这个视图是在每个SQL语句开始执行的时候创建的。
    *这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；
    *而“串行化”隔离级别下直接用加锁的方式来避免并行访问。
  
    不同隔离级别ReadView实现方式
    1. read-commited:
      即：在每次语句执行的过程中，都关闭read_view, 重新在row_search_for_mysql函数中创建当前的一份read_view。
      这样就会产生不可重复读现象发生。

    2. repeatable read：
      在repeatable read的隔离级别下，创建事务trx结构的时候，就生成了当前的global read view。
      使用trx_assign_read_view函数创建，一直维持到事务结束。在事务结束这段时间内 每一次查询都不会重新重建Read View ，
      从而实现了可重复读。

****************************************************************************************************
  Oracle数据库的默认隔离级别其实就是“读提交”，因此对于一些从Oracle迁移到MySQL的应用，为保证数据库隔离级别的一致，
  一定要记得将MySQL的隔离级别设置为“读提交”。
  
  什么时候需要“可重复读”的场景呢？我们来看一个数据校对逻辑的案例。
    假设你在管理一个个人银行账户表。一个表存了每个月月底的余额，一个表存了账单明细。这时候你要做数据校对，
    也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，
    即使有用户发生了一笔新的交易，也不影响你的校对结果。
    这时候使用“可重复读”隔离级别就很方便。事务启动时的视图可以认为是静态的，不受其他事务更新的影响。
    
  事务启动方式有以下几种：
    *显式启动事务语句， begin 或 start transaction。配套的提交语句是commit，回滚语句是rollback。
    *set autocommit=0，这个命令会将这个线程的自动提交关掉。意味着如果你只执行一个select语句，这个事务就启动了，
      而且并不会自动提交。这个事务持续存在直到你主动执行commit 或 rollback 语句，或者断开连接。
    
  为什么建议你尽量不要使用长事务。
    *长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，
      数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。
    *除此之外，长事务还占用锁资源，可能会拖垮库。
  
  尝试回答这些问题检查自己的掌握程度:
    1.事务的概念是什么?
    2.mysql的事务隔离级别读未提交, 读已提交, 可重复读, 串行各是什么意思?
    3.读已提交, 可重复读是怎么通过视图构建实现的?
    4.可重复读的使用场景举例? 对账的时候应该很有用?
    5.事务隔离是怎么通过read-view(读视图)实现的?
    6.并发版本控制(MCVV)的概念是什么, 是怎么实现的?
    7.使用长事务的弊病? 为什么使用常事务可能拖垮整个库?
    8.事务的启动方式有哪几种? 
    9.commit work and chain的语法是做什么用的? 
    10.怎么查询各个表中的长事务?
    11.如何避免长事务的出现?
  
  
